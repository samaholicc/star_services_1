"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const log_1 = tslib_1.__importDefault(require("../../log"));
const EndRollout_1 = require("../../rollout/actions/EndRollout");
const ManageRollout_1 = require("../../rollout/actions/ManageRollout");
const NonInteractiveRollout_1 = require("../../rollout/actions/NonInteractiveRollout");
const RolloutMainMenu_1 = require("../../rollout/actions/RolloutMainMenu");
var ActionRawFlagValue;
(function (ActionRawFlagValue) {
    ActionRawFlagValue["CREATE"] = "create";
    ActionRawFlagValue["EDIT"] = "edit";
    ActionRawFlagValue["END"] = "end";
})(ActionRawFlagValue || (ActionRawFlagValue = {}));
class ChannelRolloutPreview extends EasCommand_1.default {
    async runAsync() {
        const { args, flags } = await this.parse(ChannelRolloutPreview);
        const argsAndFlags = this.sanitizeArgsAndFlags({ ...flags, ...args });
        const { privateProjectConfig: { exp, projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(ChannelRolloutPreview, {
            nonInteractive: argsAndFlags.nonInteractive,
        });
        if (argsAndFlags.json) {
            // TODO(quin): implement json output
            throw new Error('Developer Preview doesnt support JSON output yet');
        }
        const app = { projectId, exp };
        const ctx = {
            projectId,
            nonInteractive: argsAndFlags.nonInteractive,
            graphqlClient,
            app,
        };
        if (argsAndFlags.nonInteractive) {
            await new NonInteractiveRollout_1.NonInteractiveRollout(argsAndFlags).runAsync(ctx);
        }
        else {
            log_1.default.addNewLineIfNone();
            log_1.default.warn(`âœ¨ This command is in Developer Preview and has not been released to production yet`);
            log_1.default.addNewLineIfNone();
            await new RolloutMainMenu_1.RolloutMainMenu(argsAndFlags).runAsync(ctx);
        }
    }
    getAction(action) {
        switch (action) {
            case ActionRawFlagValue.CREATE:
                return RolloutMainMenu_1.MainMenuActions.CREATE_NEW;
            case ActionRawFlagValue.EDIT:
                return ManageRollout_1.ManageRolloutActions.EDIT;
            case ActionRawFlagValue.END:
                return ManageRollout_1.ManageRolloutActions.END;
        }
    }
    sanitizeArgsAndFlags(rawFlags) {
        const action = rawFlags.action;
        return {
            channelName: rawFlags.channel,
            percent: rawFlags.percent,
            outcome: rawFlags.outcome,
            branchNameToRollout: rawFlags.branch,
            runtimeVersion: rawFlags['runtime-version'],
            action: action ? this.getAction(action) : undefined,
            nonInteractive: rawFlags['non-interactive'],
            json: rawFlags.json,
        };
    }
}
exports.default = ChannelRolloutPreview;
_a = ChannelRolloutPreview;
ChannelRolloutPreview.hidden = true;
ChannelRolloutPreview.description = 'Roll a new branch out on a channel incrementally.';
ChannelRolloutPreview.args = [
    {
        name: 'channel',
        description: 'channel on which the rollout should be done',
    },
];
ChannelRolloutPreview.flags = {
    action: core_1.Flags.enum({
        description: 'Rollout action to perform',
        options: Object.values(ActionRawFlagValue),
        required: false,
        relationships: [
            {
                type: 'all',
                flags: [
                    {
                        name: 'percent',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => {
                            return (!!flags['non-interactive'] &&
                                (flags['action'] === ActionRawFlagValue.CREATE ||
                                    flags['action'] === ActionRawFlagValue.EDIT));
                        },
                    },
                    {
                        name: 'outcome',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.END,
                    },
                    {
                        name: 'branch',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.CREATE,
                    },
                    {
                        name: 'runtime-version',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.CREATE,
                    },
                ],
            },
        ],
    }),
    percent: core_1.Flags.integer({
        description: 'Percent of users to send to the new branch. Use with --action=edit or --action=create',
        required: false,
    }),
    outcome: core_1.Flags.enum({
        description: 'End outcome of rollout. Use with --action=end',
        options: Object.values(EndRollout_1.EndOutcome),
        required: false,
    }),
    branch: core_1.Flags.string({
        description: 'Branch to rollout. Use with --action=create',
        required: false,
    }),
    'runtime-version': core_1.Flags.string({
        description: 'Runtime version to target. Use with --action=create',
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
ChannelRolloutPreview.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
